# Copyright (C) 2018-2025 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

# Test invoking functions on multiple threads, one after the other.

standard_testfile

if {[gdb_compile_pthreads "${srcdir}/${subdir}/${srcfile}" "${binfile}" \
  executable {debug additional_flags=-std=gnu99}] != "" } {
  return -1
}

clean_restart "${binfile}"

if {![runto_main]} {
   return 0
}

# Ensure that each new pthread is spawned one at a time so we can
# extract its target ID, and not the ID of some auxiliary thread
# spawned by the runtime.
gdb_breakpoint [gdb_get_line_number "prethreadcreationmarker"]
gdb_continue_to_breakpoint "prethreadcreationmarker"
set after_new_thread_message "detected new pthread"

# List of the target ids detected.
set pthread_list {}

# The first 3 pthreads are detected here.
foreach_with_prefix pthread {1 2 3}  {
    gdb_test_multiple "continue" "${after_new_thread_message}" {
	-re -wrap "\\\[New (Thread \[^\r\n\]+)\\\]\r\n.*" {
	    set thr $expect_out(1,string)
	    verbose -log "detected pthread: $thr"
	    lappend pthread_list $thr
	    pass $gdb_test_name
	}
    }
}

verbose -log "detected pthread list: $pthread_list"

gdb_breakpoint [gdb_get_line_number "testmarker01"]

# Continue to breakpoint.  This detects that last pthread.  It also
# ensures that no pthread ends up blocked in a syscall, which is
# important for Windows -- the infcall wouldn't be able to complete
# until the syscall returns, meaning, the infcall would deadlock.
with_test_prefix "pthread 4" {
    gdb_test_multiple "continue" "${after_new_thread_message}" {
	-re "\\\[New (Thread \[^\r\n\]+)\\\]\r\n" {
	    set thr $expect_out(1,string)
	    verbose -log "detected pthread: $thr"
	    lappend pthread_list $thr
	    pass $gdb_test_name
	}
    }
}

# Consume the breakpoint hit and the prompt.
gdb_test_multiple "" "stop at testmarker01" {
    -re -wrap "hit Breakpoint .* testmarker01 .*" {
	pass $gdb_test_name
    }
}

gdb_test_no_output "set scheduler-locking on"
gdb_test "show scheduler-locking" \
  "Mode for locking scheduler during execution is \"on\"."

set thread_count [get_valueof "" "\$_inferior_thread_count" 0]

# pthread id to be used in test messages in the loop below.
set testing_pthread 0

for {set thread 1} {$thread <= $thread_count} {incr thread} {

    # 1 if found, 0 if not found, -1 if the test failed.
    set found -1
    gdb_test_multiple "thread ${thread}" "extract thread target id" {
	-re -wrap "Switching to thread $decimal \\((Thread \[^\r\n\]+)\\)\\\]\r\n.*" {
	    set thr $expect_out(1,string)
	    verbose -log "extracted: $thr"
	    if {[lsearch -exact $pthread_list $thr] != -1} {
		set found 1
	    } else {
		set found 0
	    }
	}
    }
    if {$found == -1} {
	# gdb_test_multiple already issued a FAIL above.  No point in
	# continuing.
	return
    } elseif {$found == 0} {
	# Not recognized as a testcase pthread, so it must be a thread
	# spawned by the runtime or the OS.  Don't use it for testing
	# the infcall, as the thread may be blocked in a syscall -- on
	# Windows, the infcall wouldn't be able to complete until the
	# syscall returns, meaning, the infcall would deadlock.
	verbose -log "not a known pthread"
	continue
    } else {
	incr testing_pthread
	with_test_prefix "pthread $testing_pthread" {
	    gdb_test "call get_value()" "= $testing_pthread" \
		"call inferior function"
	}
    }
}

gdb_assert {$testing_pthread == 4} "tested all pthreads"

# Cygwin very often hangs closing GDB if we don't do this?  But WHY???
# I don't really know.  I seems like GDB never sees stdin close.  But
# then, DejaGnu sends kill after some seconds of timeout, and that
# fails to kill gdb too.  On top of that, if I do "kill -9 GDBPID" on
# another command line, GDB does die, and the testrun finishes...  For
# now, force-kill so that the testsuite doesn't hang...
gdb_test "with confirm off -- kill" ".*"
